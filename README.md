# Forth. Транслятор и модель

---

- Выполнил: Ступин Тимур Русланович, P3208
- `forth | risc | harv | hw | tick | binary | trap | mem | pstr | prob2 | superscalar`

## Язык программирования

### Синтаксис

Расширенная форма Бэкуса-Наура:

```ebnf
program ::= term EOF

term ::= word
       | statement
       | term term

word ::= number
       | operation
       | symbol

symbol ::= defined-word
         | variable-name

operation ::= arithmetic-operation
            | stack-operation
            | logical-operation
            | io-operation
            | memory-operation

arithmetic-operation ::= "+" | "-" | "*" | "/"

stack-operation ::= "dup" | "drop" | "swap"

logical-operation ::= "=" | "!=" | ">" | ">=" | "<" | "<="

io-operation ::= "." | "," | ('."' literal '"')

memory-operation ::= "!" | "@"

statement ::= definition-statement
            | declaration-statement
            | interrupt-statement

definition-statement ::= ":" defined-word statement-body ";"

statement-body ::= block
                | if-statement
                | loop-statement
                | statement-body statement-body

declaration-statement ::= "var" variable-name

interrupt-statement ::= "begin_int" block "ind_int"

block ::= word
        | block block

if-statement ::= "if" block ("then" | ("else" block "then"))

loop-statement ::= "begin" block "until"
```

### Семантика

- `+` -- сложить два верхних элемента стека и положить результат в стек. Операнды убираются из стека
- `-` -- вычесть первое значение в стеке из второго и положить результат в стек. Операнды убираются из стека
- `*` -- перемножить два верхних элемента стека и результат положить в стек. Операнды убираются из стека
- `/` -- разделить нацело второй элемент стека на первый и положить результат в стек. Операнды убираются из стека
- `dup` -- продублировать верхний элемент стека
- `drop` -- удалить верхний элемент стека
- `swap` -- поменять местами верхний элемент стека и элемент после него
- `<number>` -- положить значение `number` на вершину стека
- `=` -- сравнить на равенство первый и второй элементы стека и положить результат в стек. Операнды убираются из стека
- `>` -- проверить что второй элемент стека строго больше первого и положить результат в стек. Операнды убираются из
  стека
- `<` -- проверить что второй элемент стека строго меньше первого и положить результат в стек. Операнды убираются из
  стека
- `>=` -- проверить что второй элемент стека больше либо равен первого и положить результат в стек. Операнды убираются
  из
  стека
- `<=` -- проверить что второй элемент стека меньше либо равен первого и положить результат в стек. Операнды убираются
  из стека
- `.` -- взять верхний элемент стека и вывести его в стандартный поток вывода
- `." <literal> "` -- вывести литерал в стандартный поток вывода
- `,` -- прочитать значение из стандартного потока ввода и положить его в стек
- `!` -- взять верхний элемент стека и сохранить его по адресу хранящемуся во втором элементе стека. И значение и адрес
  убираются из стека
- `@` -- взять адрес из первого элемента стека и добавить значение, хранящееся по этому адрес в стек. Адрес убирается из
  стека
- `begin_int <block> end_int` -- определить обработчик прерывания
- `if <block> then` -- если значение верхнего элемента стека истинно, выполнить набор инструкций из `block`. Верхний
  элемент убирается из стека
- `if <block1> else <block2> then` -- если значение верхнего элемента стека истинно, выполнить набор инструкций из
  `block1`, иначе выполнить набор инструкция из `block2`. Верхний элемент убирается из стека
- `begin <block> until` -- если после того как выполнены инструкции из `block` верхний элемент стека не нулевой (true),
  то блок выполняется ещё раз. При проверке верхний элемент из стека
- `var <name>` -- объявить переменную с именем `name`. При этом переменная привязывается к конкретной ячейке памяти (
  аллокация)
- `: <name> <body> ;` -- создать объявление с именем `name` и содержимым `body`.
- `<definition-name>` -- на этапе компиляции данное значение заменяется блоком, соответствующим указанному объявлению
- `<variable-name>` -- положить на вершину стека адрес переменной с именем `variable-name`

#### Комментарии

TO BE DONE

#### Особенности реализации

- Циклы и условия могут быть только внутри определений (`definition`)
- В ситуациях когда происходят проверки на истинность за `false` принимается нулевое значение, а любое другое значение
  считается равным `true`
- Все определения (`definition`) заменяются на своё содержимое на этапе компиляции
- Все блоки обработки прерываний объединяются в один и автоматически привязываются к 0-му вектору
  прерываний, который соответствует стандартному потоку ввода.

#### Порядок выполнения

Программа выполняется последовательно, одна инструкция за другой

#### Память

- Распределяется статически на этапе трансляции
- Является общей для всей программы
- Строковые литералы хранятся в памяти в формате Pascal-string
- Стек является частью памяти и растёт вниз от больших адресов к меньшим

#### Области видимости

Все данные расположены в одной глобальной области видимости

#### Типизация, виды литералов

В языке определены два вида литералов:

- Строковые
- Целочисленные

Строковые литералы размещаются в памяти в формате Pascal-string.

Целочисленные литералы загружаются прямой загрузкой в случае если их значение помещается в 12 бит аргумента
непосредственной загрузки. Иначе загрузка происходит в 2 этапа, с использованием операции `lui`

Типизация отсутствует, так как переменные вводимые пользователем являются указателями на ячейку памяти и не привязаны к
типу.

## Организация памяти

- Гарвардская архитектура
- Размер машинного слова:

    - Память команд: 32 бита
    - Память данных: 32 бита

- Имеет линейное адресное пространство
- В памяти данных хранятся статические строки и переменные
- В памяти команд хранятся инструкции для выполнения
- Взаимодействие с памятью происходит через конструкции `!` и `@`
- Виды адресации:

    - Прямая абсолютная
    - Относительная (по памяти команд, относительно PC)

- Данные в памяти хранятся в формате Big-endian
- При размещении строковых литералов они хранятся в формате Pascal-string, при этом байты упаковываются не плотно (одно
  машинное слово -- один символ)
- Все переменные отображаются в память на этапе трансляции
- Стек является частью памяти данных, увеличивается вниз начиная с конца (от наибольшего адреса)
- В начале памяти данных зарезервировано место для ячеек ввода-вывода

```
          Data memory
+------------------------------+
| 00  : input cell             |
| 01  : output cell            |
| 02  : str literals           |
| 03  : str literals           |
|    ...                       |
| k+0 : variable 1             |
| k+1 : variable 2             |
|    ...                       |
| n-2 : stack                  |
| n-1 : stack                  |
+------------------------------+
```

### Регистры

В модели присутствуют следующие регистры общего назначения:

- `SP` -- указатель стека
- `T0` -- вспомогательный регистр
- `T1` -- вспомогательный регистр
- `T2` -- вспомогательный регистр
- `T3` -- вспомогательный регистр
- `ZERO` -- машинный 0

Для адресации по памяти инструкций используется регистр `PC`

Для работы с прерываниями в модели также присутствуют следующие регистры:

1. `PC_BUF` -- регистр для сохранения `PC` при переходе к подпрограмме обработки прерываний
2. `INT_RQ` -- регистр хранящий флаг запроса прерывания
3. `INT_ADDR` -- регистр хранящий адрес подпрограммы обработки прерываний
4. `INT_EN` -- регистр хранящие флаг, который определяет разрешены ли прерывания

> Решение использовать один регистр для хранения адреса подпрограммы обработки прерываний вместо векторов
> прерываний было обусловлено тем, что задание не предполагает наличие более одного внешнего устройства.

Для сохранения состояния регистров общего назначения при появлении прерывания в модели используется
`shadow register file`, который содержит все регистры общего назначения кроме `ZERO`.

> Решение использовать `shadow register file` вместо стандартного для `risc` сохранения регистров в стек было принято
> из-за того, что язык forth полностью строится на стеке, а значит заполнять его какими-либо данными помимо тех что
> предполагаются программой невозможно.

## Система команд

### Особенности процессора

- Доступ к памяти осуществляется при помощи инструкций `load` и `store`
- Устройство ввода-вывода: `memory-mapped`, ввод и вывод привязаны к $0$-му и $1$-му адресу в памяти данных
  соответственно
- Ввод осуществляется по прерыванию
- Адрес подпрограммы обработки прерываний задаётся в регистре `INT_ADDR`
- Разрешение или запрет прерываний можно задать установкой флага в регистре `INT_EN`
- Перед переходом к подпрограмме обработки прерываний регистры общего назначения сохраняются в `shadow register file`
- В ходе работы процессор может находиться в одном из состояний:

    - `NORMAL` -- обычный режим работы, происходит последовательное извлечение инструкций из памяти команд и их
      выполнение
    - `INT_ENTER` -- в этом режиме происходит сохранение регистров общего назначения в `shadow register file`, и переход
      к подпрограмме обработки прерывания
    - `INT_BODY` -- этот режим полностью повторяет режим `NORMAL`, за исключением запрета прерываний в нём
    - `INT_EXIT` -- в этом режиме происходит восстановление значений регистров общего назначения и возврат из прерывания

- Прерываний запрещены в состояниях `INT_ENTER` и `INT_BODY`. В остальных состояния они разрешены
- Так как язык `forth` построен на использовании стека, подпрограммы обработки прерываний не должны изменить состояние
  стека

#### Цикл обработки прерываний

В начале каждого такта происходит поиск номера такта в расписании прерываний. В случае если найдено совпадение,
прерывания разрешены и процессор находится в состоянии не запрещающем прерывания, происходит
установка флага запроса прерывания, а в `input_buffer` в `data-path` записывается пришедший
символ.

> Механика установки флага вместо мгновенной смены состояния была введена для решения двух проблем:
>1. Предотвращение перехода к циклу прерывания во время исполнения много-тактовой инструкции (например работы с памятью)
>2. Обеспечение возможности запомнить факт запроса прерывания, даже если нет возможность обработать его прямо сейчас (
    например во время цикла выхода из прерывания, когда значения пришедшие в прошлом прерывании уже обработаны и ничто
    не мешает перезаписать их новыми, чтобы обработать по окончании цикла выхода из прерывания)

Таким образом, на каждом такте также происходи проверка флага запроса прерывания. В случае если
он установлен, состояние процессора сейчас `NORMAL` и шаг (`step`) равен нулю (то есть мы не внутри много-тактовой
инструкции) происходит смена состояния на `INT_ENTER`.

Когда процессор находится в состоянии `INT_ENTER` выполняется сохранение всех регистров общего
назначения в `shadow register file`. В одном такте с этой операцией происходит сохранение значения регистра `PC` в
регистр `PC_BUF`. В следующем такте происходит запись значения из регистра `INT_ADDR` в регистр `PC`, а состояние
процессора меняется на `INT_BODY`

В состоянии `INT_BODY` процессор так же как и в состоянии `NORMAL` последовательно выполняет инструкции. Разница только
в том, что прерывания в нём запрещены.

Для выхода из подпрограммы обработки прерывания определена специальная инструкция `rint` которая переводит процессор в
состояние `INT_EXIT`.

В состоянии `INT_EXIT` происходит восстановление значений регистров общего назначения из `shadow register file`, и в
одном такте с этим в регистр `PC` записывается значение из регистра `PC_BUF`. В конце состояние процессора меняется на
`NORMAL`

### Набор инструкций

| Название | Синтаксис              | Число тактов | Мнемоника                                                                                        | Описание                                                                                                    |
|:---------|------------------------|:-------------|:-------------------------------------------------------------------------------------------------|:------------------------------------------------------------------------------------------------------------|
| `lui`    | `lui <rd> <k>`         | 1            | `rd <- k << 12`                                                                                  | Выполняет прямую загрузку значения `k`, сдвинутого влево на 12 бит в регистр `rd`                           |
| `j`      | `j <k>`                | 1            | `pc <- pc + k`                                                                                   | Выполняет переход через смещение на `k` относительно `PC`                                                   |
| `sw`     | `sw <rs1> <rs2>`       | 2            | `M[rs1] <- rs2`                                                                                  | Выполняет сохранение значения из регистра `rs2` по адресу записанному в регистр `rs1`                       |
| `lw`     | `lw <rs1> <rd>`        | 2            | `rd <- M[rs1]`                                                                                   | Выполняет сохранение значения из памяти по адресу записанному в регистр `rs1` в регистр `rd`                |
| `addi`   | `addi <rs1> <rd> <k>`  | 1            | `rd <- rs1 + k`                                                                                  | Выполняет сохранение увеличенное на `k` значения регистра `rs1` в регистр `rd`                              |
| `jr`     | `jr <rs1> <k>`         | 1            | `rd <- pc + 1`<br/>`pc <- rs1 + k`                                                               | Выполняет переход через смещение на `k` относительно `rs1` с сохранением адреса следующей инструкции в `rd` |
| `beq`    | `beq <rs1> <rs2> <k>`  | 2            | `zero <- rs1 - rs2`<br/>`IF zero_flag THEN pc <- pc + k`                                         | Выполняет переход через смещение на `k` относительно `PC` в случае равенства `rs1` и `rs2`                  |
| `bne`    | `bne <rs1> <rs2> <k>`  | 2            | `zero <- rs1 - rs2`<br/>`IF NOT zero_flag THEN pc <- pc + k`                                     | Выполняет переход через смещение на `k` относительно `PC` в случае НЕ равенства `rs1` и `rs2`               |
| `bgt`    | `bgt <rs1> <rs2> <k>`  | 2            | `zero  <- rs1 - rs2`<br/>`IF NOT zero_flag AND negative_flag == overflow_flag THEN pc <- pc + k` | Выполняет переход через смещение на `k` относительно `PC` в случае если `rs1` строго больше `rs2`           |
| `blt`    | `blt <rs1> <rs2> <k>`  | 2            | `zero  <- rs1 - rs2`<br/>`IF NOT zero_flag AND negative_flag != overflow_flag THEN pc <- pc + k` | Выполняет переход через смещение на `k` относительно `PC` в случае если `rs1` строго меньше `rs2`           |
| `add`    | `add <rs1> <rs2> <rd>` | 1            | `rd <- rs1 + rs2`                                                                                | Выполняет суммирование `rs1` и `rs2` сохраняя результат в `rd`                                              |
| `sub`    | `sub <rs1> <rs2> <rd>` | 1            | `rd <- rs1 - rs2`                                                                                | Выполняет вычитание `rs2` из `rs1` сохраняя результат в `rd`                                                |
| `mul`    | `mul <rs1> <rs2> <rd>` | 1            | `rd <- rs1 * rs2`                                                                                | Выполняет умножение `rs1` на `rs2` сохраняя результат в `rd`                                                |
| `div`    | `div <rs1> <rs2> <rd>` | 1            | `rd <- rs1 // rs2`                                                                               | Выполняет целочисленное деление `rs1` на `rs2` сохраняя результат в `rd`                                    |
| `rem`    | `rem <rs1> <rs2> <rd>` | 1            | `rd <- rs1 % rs2`                                                                                | Выполняет взятие остатка от деление `rs1` на `rs2` сохраняя результат в `rd`                                |
| `sll`    | `sll <rs1> <rs2> <rd>` | 1            | `rd <- rs1 << rs2`                                                                               | Выполняет логический сдвиг `rs1` влево на `rs2` бит сохраняя результат в `rd`                               |
| `srl`    | `srl <rs1> <rs2> <rd>` | 1            | `rd <- rs1 >> rs2`                                                                               | Выполняет логический сдвиг `rs1` вправо на `rs2` бит сохраняя результат в `rd`                              |
| `and`    | `and <rs1> <rs2> <rd>` | 1            | `rd <- rs1 & rs2`                                                                                | Выполняет побитовое И между `rs1` и `rs2` сохраняя результат в `rd`                                         |
| `or`     | `or <rs1> <rs2> <rd>`  | 1            | `rd <- rs1 \| rs2`                                                                               | Выполняет побитовое ИЛИ между `rs1` и `rs2` сохраняя результат в `rd`                                       |
| `xor`    | `xor <rs1> <rs2> <rd>` | 1            | `rd <- rs1 ^ rs2`                                                                                | Выполняет побитовый XOR между `rs1` и `rs2` сохраняя результат в `rd`                                       |
| `halt`   | `halt`                 | 1            | -                                                                                                | Выполняет остановку моделирования                                                                           |
| `rint`   | `rint`                 | 1            | `state <- INT_EXIT`                                                                              | Выполняет выход из подпрограммы обработки прерывания                                                        |

### Способ кодирования инструкций

Все инструкции имеют фиксированный размер - 32 бита. В младших 7 битах всегда хранится opcode. Дальнейшее содержимое
бинарного представления инструкции зависит от её типа.

В данной модели процессора выделяется 7 видов инструкций:

1. `R` -- инструкции для выполнения арифметических и логических операций над данными в регистрах. Например `add`, `sub`.
2. `I` -- инструкции, использующие непосредственные (константные) значения. Например `addi`, `lw`.
3. `S` -- инструкции для записи работы с памятью. Например `sw`.
4. `B` -- инструкции для условных переходов. Например `beq`, `bgt`.
5. `U` -- инструкции для загрузки больших непосредственных значений в регистры. Например `lui`.
6. `J` -- инструкции для выполнения безусловных переходов со смещением относительно счётчика команд. Например `j`.
7. `JR` -- инструкции для выполнения безусловных переходов со смещением относительно регистра. Например `jr`.

#### Бинарное представление

Кодирование этих инструкций происходит следующим образом:

```
┌─────┬───────────────────────────────┬─────────┬─────────┬────────┬────────┐
│ тип │           31...22             │ 21...17 │ 16...12 │ 11...7 │  6..0  │
├─────┼───────────────────────────────┼─────────┼─────────┼────────┼────────┤
│  R  │                               │   rs2   │   rs1   │   rd   │ opcode │
├─────┼───────────────────────────────┴─────────┼─────────┼────────┼────────┤
│  I  │                   imm                   │   rs1   │   rd   │ opcode │
├─────┼─────────────────────────────────────────┴─────────┼────────┼────────┤
│  U  │                         imm                       │   rd   │ opcode │
├─────┼───────────────────────────────┬─────────┬─────────┼────────┼────────┤
│  S  │                               │   rs2   │   rs1   │        │ opcode │
├─────┼───────────────────────────────┼─────────┼─────────┼────────┼────────┤
│  B  │              imm              │   rs2   │   rs1   │   imm  │ opcode │
├─────┼───────────────────────────────┴─────────┴─────────┴────────┼────────┤
│  J  │                             imm                            │ opcode │
├─────┼─────────────────────────────────────────┬─────────┬────────┼────────┤
│ JR  │                   imm                   │   rs1   │        │ opcode │
└─────┴─────────────────────────────────────────┴─────────┴────────┴────────┘
```

Также есть инструкции которые не имеют типа, так как влияют исключительно на состояние процессора. Это инструкции `halt`
и `rint`.
Их бинарное представление имеет следующий вид:

```
┌──────────────────────────────────────────────────────────────────┬────────┐
│                             31...7                               │  6..0  │
├──────────────────────────────────────────────────────────────────┼────────┤
│                                                                  │ opcode │
└──────────────────────────────────────────────────────────────────┴────────┘
```

Коды операций:

- `0000001` (`0x01`) -- `lui` -- загрузить верхнюю часть непосредственного значения в регистр
- `0000010` (`0x02`) -- `sw` -- сохранить слово из регистра в память
- `0000011` (`0x03`) -- `lw` -- загрузить слово из памяти в регистр
- `0000100` (`0x04`) -- `addi` -- прибавить непосредственное значение к регистру
- `0000101` (`0x05`) -- `add` -- сложить значения двух регистров
- `0000110` (`0x06`) -- `sub` -- вычесть значение одного регистра из другого
- `0000111` (`0x07`) -- `mul` -- умножить значения двух регистров
- `0001000` (`0x08`) -- `div` -- разделить значения двух регистров
- `0001001` (`0x09`) -- `rem` -- получить остаток от деления двух регистров
- `0001010` (`0x0A`) -- `sll` -- сдвинуть значение регистра влево
- `0001011` (`0x0B`) -- `srl` -- сдвинуть значение регистра вправо
- `0001100` (`0x0C`) -- `and` -- выполнить побитовое И над двумя регистрами
- `0001101` (`0x0D`) -- `or` -- выполнить побитовое ИЛИ над двумя регистрами
- `0001110` (`0x0E`) -- `xor` -- выполнить побитовое ИСКЛЮЧАЮЩЕЕ ИЛИ над двумя регистрами
- `0001111` (`0x0F`) -- `beq` -- перейти, если значения двух регистров равны
- `0010000` (`0x10`) -- `bne` -- перейти, если значения двух регистров не равны
- `0010001` (`0x11`) -- `bgt` -- перейти, если значение одного регистра больше другого
- `0010010` (`0x12`) -- `blt` -- перейти, если значение одного регистра меньше другого
- `0010011` (`0x13`) -- `j` -- перейти со смещением относительно счётчика команд
- `0010100` (`0x14`) -- `jr` -- перейти со смещением относительно регистра
- `0010101` (`0x15`) -- `halt` -- остановить выполнение программы
- `0010110` (`0x16`) -- `rint` -- возврат из прерывания

#### JSON представление

- Машинный код сериализуется в JSON список.
- Один элемент списка -- одна инструкция.

Пример:

```json
[
  {
    "address": 0,
    "opcode": "addi",
    "rd": "t0",
    "rs1": "zero",
    "imm": -10
  },
  {
    "address": 1,
    "opcode": "addi",
    "rd": "sp",
    "rs1": "sp",
    "imm": -1
  },
  {
    "address": 2,
    "opcode": "sw",
    "rd": "None",
    "rs1": "sp",
    "rs2": "t0"
  }
]
```

Где:

- `address` -- адрес инструкции
- `opcode` -- код операции
- `rd`, `rs1`, `rs2`, `imm` -- различные аргументы инструкций

