# Forth. Транслятор и модель

---

- Выполнил: Ступин Тимур Русланович, P3208
- `forth | risc | harv | hw | tick | binary | trap | mem | pstr | prob2 | superscalar`

## Язык программирования

### Синтаксис

Расширенная форма Бэкуса-Наура:

```ebnf
program ::= term EOF

term ::= word
       | statement
       | term term

word ::= symbol
       | number
       | extended-number
       | operation

statement ::= definition-statement
            | declaration-statement
            | interrupt-statement

symbol ::= defined-word
         | variable-name

number ::= [-2^31; 2^31 - 1]

extended-number ::= [-2^63; 2^63 - 1]'.'

operation ::= arithmetic-operation
            | extended-arithmetic-operation
            | binary-operation
            | logical-operation
            | stack-operation
            | memory-operation
            | io-operation
            | interrupt-operation

definition-statement ::= ':' defined-word statement-body ';'

declaration-statement ::= variable-declaration
                       |  d-variable-declaration
                       |  string-literal-declaration
                       |  memory-block-declaration

interrupt-statement ::= 'begin_int' block 'end_int'

arithmetic-operation ::= '+' | '-' | '*' | '/'

extended-arithmetic-operation ::= '2+' | '2*'

binary-operation ::= 'and' | 'or' | 'not' | 'xor'

logical-operation ::= '=' | '!=' | '>' | '>=' | '<' | '<='

stack-operation ::= 'dup' | 'drop' | 'swap'

memory-operation ::= 'store' | 'load'

io-operation ::= 'print' | 'read'

interrupt-operation ::= 'en_int' | 'di_int'

statement-body ::= block
                |  if-statement
                |  loop-statement
                |  statement-body

variable-declaration ::= 'var' variable-name

d-variable-declaration ::= '2var' variable-name

string-literal-declaration ::= 'str' variable-name literal

memory-block-declaration ::= 'alloc' variable-name memory-block-size

block ::= word
        | block block

if-statement ::= 'if' statement-body ('then' | ('else' statement-body 'then'))

loop-statement ::= 'begin' statement-body 'until'

literal ::= '"' ascii-symbol'"'

memory-block-size ::= [1; 2^31 - 1]
```

### Семантика

- `<number>` -- положить значение `number` на вершину стека
- `<extended-number>.` -- положить значение двойной точности `extended-number` на стек (сначала младшая часть, потом
  старшая)
- `+` -- сложить два верхних элемента стека и положить результат на стек. Операнды убираются со стека
- `-` -- вычесть первое значение на стеке из второго и положить результат на стек. Операнды убираются со стека
- `*` -- перемножить два верхних элемента стека и результат положить на стек. Операнды убираются со стека
- `/` -- разделить нацело второй элемент стека на первый и положить результат на стек. Операнды убираются со стека
- `2+` -- сложить два числа двойной точности и положить результата на стек. Операнды убираются со стека
- `2*` -- перемножить два верхних элемента стека и положить результат в виде числа двойной точности на стек. Операнды
  убираются со стека
- `and` -- выполнить операцию побитового `И` между двумя верхними элементами стека и результат положить на стек.
  Операнды убираются со стека
- `or` -- выполнить операцию побитового `ИЛИ` между двумя верхними элементами стека и результат положить на стек.
  Операнды убираются со стека
- `not` -- выполнить операцию побитового `НЕ` над верхним элементом стека.
- `xor` -- выполнить операцию побитового `XOR` между двумя верхними элементами стека и результат положить на стек.
  Операнды убираются со стека
- `=` -- сравнить на равенство первый и второй элементы стека и положить результат на стек. Операнды убираются со стека
- `!=` -- сравнить на неравенство первый и второй элементы стека и положить результат на стек. Операнды убираются со
  стека
- `>` -- проверить что второй элемент стека строго больше первого и положить результат на стек. Операнды убираются со
  стека
- `<` -- проверить что второй элемент стека строго меньше первого и положить результат на стек. Операнды убираются со
  стека
- `>=` -- проверить что второй элемент стека больше либо равен первого и положить результат на стек. Операнды убираются
  со стека
- `<=` -- проверить что второй элемент стека меньше либо равен первого и положить результат на стек. Операнды убираются
  со стека
- `dup` -- продублировать верхний элемент стека
- `drop` -- удалить верхний элемент стека
- `swap` -- поменять местами верхний элемент стека и элемент после него
- `store` -- взять верхний элемент стека и сохранить его по адресу хранящемуся во втором элементе стека. И значение и
  адрес
  убираются со стека
- `load` -- взять адрес из первого элемента стека и положить значение, хранящееся по этому адрес на стек. Адрес
  убирается
  со стека
- `print` -- взять верхний элемент со стека и вывести его в стандартный поток вывода
- `read` -- прочитать значение из стандартного потока ввода и положить его на стек
- `begin_int <block> end_int` -- определить обработчик прерывания
- `if <block> then` -- если значение верхнего элемента стека истинно, выполнить набор инструкций из `block`. При
  проверке элемент убирается со стека
- `if <block1> else <block2> then` -- если значение верхнего элемента стека истинно, выполнить набор инструкций из
  `block1`, иначе выполнить набор инструкция из `block2`. При проверке элемент убирается со стека
- `begin <block> until` -- если после того как выполнены инструкции из `block` верхний элемент стека не нулевой (true),
  то блок выполняется ещё раз. При проверке элемент убирается со стека
- `var <name>` -- объявить переменную с именем `name`. При этом переменная привязывается к конкретной ячейке памяти
- `2var <name>` -- объявить переменную двойной точности с именем `name`. При этом выделяется 2 ячейки памяти, а
  переменная привязывается к адресу первой. Само число хранится в виде старшей и младшей части, записанной слева на
  право
- `str <name> " <literal> "` -- объявление строкового литерала с именем `name`. Литерал сохранятся в памяти в виде
  паскаль-строки. Переменная адресу начала строки (фактически ячейке в которой хранится длинна строки)
- `alloc <name> <size>` -- выделение блока памяти размера `size` с именем `name`. Размер указывается в ячейках памяти.
  Переменная привязывается к адресу начала блока
- `: <name> <body> ;` -- создать объявление с именем `name` и содержимым `body`
- `<definition-name>` -- на этапе компиляции данное значение заменяется блоком, соответствующим указанному объявлению
- `<variable-name>` -- положить на вершину стека адрес переменной с именем `variable-name`
- `en_int` -- разрешение прерываний
- `di_int` -- запрет прерываний

#### Комментарии

Начинаются со знака `\` и идут до конца строки

#### Особенности реализации

- Циклы и условия могут быть только внутри определений (`definition`)
- Поддерживается произвольный уровень вложенности циклов и условий
- В ситуациях когда происходят проверки на истинность за `false` принимается нулевое значение, а любое другое значение
  считается равным `true`
- Все определения (`definition`) заменяются на своё содержимое на этапе трансляции
- Все блоки обработки прерываний объединяются в один

#### Порядок выполнения

Программа выполняется последовательно, одна инструкция за другой

#### Память

- Распределяется статически на этапе трансляции
- Является общей для всей программы
- Строковые литералы хранятся в памяти в формате Pascal-string
- Память для переменных и блоков памяти выделяется статически и заполняется нулевыми значениями
- Стек является частью памяти и растёт вниз от больших адресов к меньшим

#### Области видимости

Все данные расположены в одной глобальной области видимости

#### Типизация, виды литералов

В языке определены четыре вида литералов:

- Строковые
- Целочисленные
- Целочисленные, двойной точности
- Блоки памяти

Строковые литералы размещаются в памяти в формате Pascal-string.

Целочисленные литералы загружаются прямой загрузкой в случае если их значение помещается в 12 бит аргумента
непосредственной загрузки. Иначе загрузка происходит в 2 этапа, с использованием операции `lui`

Целочисленные литералы двойной точности хранятся в двух ячейках и загружаются как два целочисленных литерала. При
размещении в стеке и памяти старшее слово размещается правее младшего.

Блоки памяти хранятся в памяти в виде непрерывной последовательности ячеек. Работа с блоками осуществляется
пользователем, встроенные операции с ними отсутствуют

Типизация отсутствует, так как переменные вводимые пользователем являются указателями на ячейку памяти и не привязаны к
типу.

## Организация памяти

- Гарвардская архитектура
- Размер машинного слова:

    - Память команд: 32 бита
    - Память данных: 32 бита

- Имеет линейное адресное пространство
- В памяти данных хранятся статические строки и переменные
- В памяти команд хранятся инструкции для выполнения
- Взаимодействие с памятью происходит через конструкции `load` и `store`
- Виды адресации:

    - Прямая абсолютная
    - Относительная (по памяти команд, относительно PC)

- Данные в памяти хранятся в формате Big-endian
- При размещении строковых литералов они хранятся в формате Pascal-string, при этом байты упаковываются не плотно (одно
  машинное слово -- один символ)
- Все переменные отображаются в память на этапе трансляции
- Стек является частью памяти данных, увеличивается вниз начиная с конца (от наибольшего адреса)
- В начале памяти данных зарезервировано место для ячеек ввода-вывода

```plaintext
          Data memory
+------------------------------+
| 00  : input cell             |
| 01  : output cell            |
| 02  : str literals           |
| 03  : str literals           |
|    ...                       |
| k+0 : variable 1             |
| k+1 : variable 2             |
|    ...                       |
| n-2 : stack                  |
| n-1 : stack                  |
+------------------------------+
```

### Регистры

В модели присутствуют следующие регистры общего назначения:

- `SP` -- указатель стека
- `T0` -- вспомогательный регистр
- `T1` -- вспомогательный регистр
- `T2` -- вспомогательный регистр
- `T3` -- вспомогательный регистр
- `ZERO` -- машинный 0

Для адресации по памяти инструкций используется регистр `PC`

Для работы с прерываниями в модели также присутствуют следующие регистры:

1. `PC_BUF` -- регистр для сохранения `PC` при переходе к подпрограмме обработки прерываний
2. `INT_RQ` -- регистр хранящий флаг запроса прерывания
3. `INT_ADDR` -- регистр хранящий адрес подпрограммы обработки прерываний
4. `INT_EN` -- регистр хранящие флаг, который определяет разрешены ли прерывания

> Решение использовать один регистр для хранения адреса подпрограммы обработки прерываний вместо векторов
> прерываний было обусловлено тем, что задание не предполагает наличие более одного внешнего устройства.

Для сохранения состояния регистров общего назначения при появлении прерывания в модели используется
`shadow register file`, который содержит все регистры общего назначения кроме `ZERO`.

> Решение использовать `shadow register file` вместо стандартного для `risc` сохранения регистров в стек было принято
> из-за того, что язык forth полностью строится на стеке, а значит заполнять его какими-либо данными помимо тех что
> предполагаются программой невозможно.

## Система команд

### Особенности процессора

- Доступ к памяти осуществляется при помощи инструкций `load` и `store`
- Устройство ввода-вывода: `memory-mapped`, ввод и вывод привязаны к $0$-му и $1$-му адресу в памяти данных
  соответственно
- Ввод осуществляется по прерыванию
- Адрес подпрограммы обработки прерываний задаётся в регистре `INT_ADDR`
- Разрешение или запрет прерываний можно задать установкой флага в регистре `INT_EN`
- Перед переходом к подпрограмме обработки прерываний регистры общего назначения сохраняются в `shadow register file`
- В ходе работы процессор может находиться в одном из состояний:

    - `NORMAL` -- обычный режим работы, происходит последовательное извлечение инструкций из памяти команд и их
      выполнение
    - `INT_ENTER` -- в этом режиме происходит сохранение регистров общего назначения в `shadow register file`, и переход
      к подпрограмме обработки прерывания
    - `INT_BODY` -- этот режим полностью повторяет режим `NORMAL`, за исключением запрета прерываний в нём
    - `INT_EXIT` -- в этом режиме происходит восстановление значений регистров общего назначения и возврат из прерывания

- Прерываний запрещены в состояниях `INT_ENTER` и `INT_BODY`. В остальных состояния они разрешены
- Так как язык `forth` построен на использовании стека, подпрограммы обработки прерываний не должны изменять состояние
  стека

#### Цикл обработки прерываний

В начале каждого такта происходит поиск номера такта в расписании прерываний. В случае если найдено совпадение,
прерывания разрешены и процессор находится в состоянии не запрещающем прерывания, происходит
установка флага запроса прерывания, а в `input_buffer` в `data-path` записывается пришедший
символ.

> Механика установки флага вместо мгновенной смены состояния была введена для решения двух проблем:
>
>1. Предотвращение перехода к циклу прерывания во время исполнения много-тактовой инструкции (например работы с памятью)
>2. Обеспечение возможности запомнить факт запроса прерывания, даже если нет возможность обработать его прямо сейчас (
    например во время цикла выхода из прерывания, когда значения пришедшие в прошлом прерывании уже обработаны и ничто
    не мешает перезаписать их новыми, чтобы обработать по окончании цикла выхода из прерывания)

Таким образом, на каждом такте также происходи проверка флага запроса прерывания. В случае если
он установлен, состояние процессора сейчас `NORMAL` и шаг (`step`) равен нулю (то есть мы не внутри много-тактовой
инструкции) происходит смена состояния на `INT_ENTER`.

Когда процессор находится в состоянии `INT_ENTER` выполняется сохранение всех регистров общего
назначения в `shadow register file`. В одном такте с этой операцией происходит сохранение значения регистра `PC` в
регистр `PC_BUF`. В следующем такте происходит запись значения из регистра `INT_ADDR` в регистр `PC`, а состояние
процессора меняется на `INT_BODY`

В состоянии `INT_BODY` процессор так же как и в состоянии `NORMAL` последовательно выполняет инструкции. Разница только
в том, что прерывания в нём запрещены.

Для выхода из подпрограммы обработки прерывания определена специальная инструкция `rint` которая переводит процессор в
состояние `INT_EXIT`.

В состоянии `INT_EXIT` происходит восстановление значений регистров общего назначения из `shadow register file`, и в
одном такте с этим в регистр `PC` записывается значение из регистра `PC_BUF`. В конце состояние процессора меняется на
`NORMAL`

### Набор инструкций

| Название | Синтаксис               | Число тактов | Мнемоника                                                                                  | Описание                                                                                                    |
|:---------|-------------------------|:-------------|:-------------------------------------------------------------------------------------------|:------------------------------------------------------------------------------------------------------------|
| `lui`    | `lui <rd> <k>`          | 1            | `rd <- k << 12`                                                                            | Выполняет прямую загрузку значения `k`, сдвинутого влево на 12 бит в регистр `rd`                           |
| `j`      | `j <k>`                 | 1            | `pc <- pc + k`                                                                             | Выполняет переход через смещение на `k` относительно `PC`                                                   |
| `sw`     | `sw <rs1> <rs2>`        | 2            | `M[rs1] <- rs2`                                                                            | Выполняет сохранение значения из регистра `rs2` по адресу записанному в регистр `rs1`                       |
| `lw`     | `lw <rs1> <rd>`         | 2            | `rd <- M[rs1]`                                                                             | Выполняет сохранение значения из памяти по адресу записанному в регистр `rs1` в регистр `rd`                |
| `addi`   | `addi <rs1> <rd> <k>`   | 1            | `rd <- rs1 + k`                                                                            | Выполняет сохранение увеличенное на `k` значения регистра `rs1` в регистр `rd`                              |
| `jr`     | `jr <rs1> <k>`          | 1            | `rd <- pc + 1; pc <- rs1 + k`                                                              | Выполняет переход через смещение на `k` относительно `rs1` с сохранением адреса следующей инструкции в `rd` |
| `beq`    | `beq <rs1> <rs2> <k>`   | 2            | `zero <- rs1 - rs2; IF zero_flag THEN pc <- pc + k`                                        | Выполняет переход через смещение на `k` относительно `PC` в случае равенства `rs1` и `rs2`                  |
| `bne`    | `bne <rs1> <rs2> <k>`   | 2            | `zero <- rs1 - rs2; IF NOT zero_flag THEN pc <- pc + k`                                    | Выполняет переход через смещение на `k` относительно `PC` в случае НЕ равенства `rs1` и `rs2`               |
| `bgt`    | `bgt <rs1> <rs2> <k>`   | 2            | `zero <- rs1 - rs2; IF NOT zero_flag AND negative_flag == overflow_flag THEN pc <- pc + k` | Выполняет переход через смещение на `k` относительно `PC` в случае если `rs1` строго больше `rs2`           |
| `blt`    | `blt <rs1> <rs2> <k>`   | 2            | `zero <- rs1 - rs2; IF NOT zero_flag AND negative_flag != overflow_flag THEN pc <- pc + k` | Выполняет переход через смещение на `k` относительно `PC` в случае если `rs1` строго меньше `rs2`           |
| `add`    | `add <rs1> <rs2> <rd>`  | 1            | `rd <- rs1 + rs2`                                                                          | Выполняет суммирование `rs1` и `rs2` сохраняя результат в `rd`                                              |
| `addс`   | `addс <rs1> <rs2> <rd>` | 1            | `rd <- ((rs1 + rs2) >> WORD_SIZE) & 1`                                                     | Выполняет суммирование `rs1` и `rs2` сохраняя флаг переноса в `rd`                                          |
| `sub`    | `sub <rs1> <rs2> <rd>`  | 1            | `rd <- rs1 - rs2`                                                                          | Выполняет вычитание `rs2` из `rs1` сохраняя результат в `rd`                                                |
| `mul`    | `mul <rs1> <rs2> <rd>`  | 1            | `rd <- rs1 * rs2`                                                                          | Выполняет умножение `rs1` на `rs2` сохраняя результат в `rd`                                                |
| `mulh`   | `mulh <rs1> <rs2> <rd>` | 1            | `rd <- (rs1 * rs2) >> WORD_SIZE`                                                           | Выполняет умножение `rs1` на `rs2` сохраняя старшую часть результат в `rd`                                  |
| `div`    | `div <rs1> <rs2> <rd>`  | 1            | `rd <- rs1 // rs2`                                                                         | Выполняет целочисленное деление `rs1` на `rs2` сохраняя результат в `rd`                                    |
| `rem`    | `rem <rs1> <rs2> <rd>`  | 1            | `rd <- rs1 % rs2`                                                                          | Выполняет взятие остатка от деление `rs1` на `rs2` сохраняя результат в `rd`                                |
| `sll`    | `sll <rs1> <rs2> <rd>`  | 1            | `rd <- rs1 << rs2`                                                                         | Выполняет логический сдвиг `rs1` влево на `rs2` бит сохраняя результат в `rd`                               |
| `srl`    | `srl <rs1> <rs2> <rd>`  | 1            | `rd <- rs1 >> rs2`                                                                         | Выполняет логический сдвиг `rs1` вправо на `rs2` бит сохраняя результат в `rd`                              |
| `and`    | `and <rs1> <rs2> <rd>`  | 1            | `rd <- rs1 & rs2`                                                                          | Выполняет побитовое И между `rs1` и `rs2` сохраняя результат в `rd`                                         |
| `or`     | `or <rs1> <rs2> <rd>`   | 1            | `rd <- rs1 \| rs2`                                                                         | Выполняет побитовое ИЛИ между `rs1` и `rs2` сохраняя результат в `rd`                                       |
| `xor`    | `xor <rs1> <rs2> <rd>`  | 1            | `rd <- rs1 ^ rs2`                                                                          | Выполняет побитовый XOR между `rs1` и `rs2` сохраняя результат в `rd`                                       |
| `halt`   | `halt`                  | 1            | -                                                                                          | Выполняет остановку моделирования                                                                           |
| `eint`   | `eint`                  | 1            | -                                                                                          | Разрешает прерывания                                                                                        |
| `dint`   | `dint`                  | 1            | -                                                                                          | Запрещает прерывания                                                                                        |
| `rint`   | `rint`                  | 1            | `state <- INT_EXIT`                                                                        | Выполняет выход из подпрограммы обработки прерывания                                                        |

### Способ кодирования инструкций

Все инструкции имеют фиксированный размер: $32$ бита. В младших $7$ битах всегда хранится opcode. Дальнейшее содержимое
бинарного представления инструкции зависит от её типа.

В данной модели процессора выделяется семь видов инструкций:

1. `R` -- инструкции для выполнения арифметических и логических операций над данными в регистрах. Например `add`, `sub`.
2. `I` -- инструкции, использующие непосредственные (константные) значения. Например `addi`, `lw`.
3. `S` -- инструкции для работы с памятью. Например `sw`.
4. `B` -- инструкции для условных переходов. Например `beq`, `bgt`.
5. `U` -- инструкции для загрузки больших непосредственных значений в регистры. Например `lui`.
6. `J` -- инструкции для выполнения безусловных переходов со смещением относительно счётчика команд. Например `j`.
7. `JR` -- инструкции для выполнения безусловных переходов со смещением относительно регистра. Например `jr`.

#### Бинарное представление

Кодирование этих инструкций происходит следующим образом:

```plaintext
┌─────┬───────────────────────────────┬─────────┬─────────┬────────┬────────┐
│ тип │           31...22             │ 21...17 │ 16...12 │ 11...7 │  6..0  │
├─────┼───────────────────────────────┼─────────┼─────────┼────────┼────────┤
│  R  │                               │   rs2   │   rs1   │   rd   │ opcode │
├─────┼───────────────────────────────┴─────────┼─────────┼────────┼────────┤
│  I  │                   imm                   │   rs1   │   rd   │ opcode │
├─────┼─────────────────────────────────────────┴─────────┼────────┼────────┤
│  U  │                         imm                       │   rd   │ opcode │
├─────┼───────────────────────────────┬─────────┬─────────┼────────┼────────┤
│  S  │                               │   rs2   │   rs1   │        │ opcode │
├─────┼───────────────────────────────┼─────────┼─────────┼────────┼────────┤
│  B  │              imm              │   rs2   │   rs1   │   imm  │ opcode │
├─────┼───────────────────────────────┴─────────┴─────────┴────────┼────────┤
│  J  │                             imm                            │ opcode │
├─────┼─────────────────────────────────────────┬─────────┬────────┼────────┤
│ JR  │                   imm                   │   rs1   │        │ opcode │
└─────┴─────────────────────────────────────────┴─────────┴────────┴────────┘
```

Также есть инструкции которые не имеют типа, так как влияют исключительно на состояние процессора. Это инструкции `halt`
и `rint`.
Их бинарное представление имеет следующий вид:

```plaintext
┌──────────────────────────────────────────────────────────────────┬────────┐
│                             31...7                               │  6..0  │
├──────────────────────────────────────────────────────────────────┼────────┤
│                                                                  │ opcode │
└──────────────────────────────────────────────────────────────────┴────────┘
```

Коды операций:

- `0000001` (`0x01`) -- `lui` -- загрузить верхнюю часть непосредственного значения в регистр
- `0000010` (`0x02`) -- `sw` -- сохранить слово из регистра в память
- `0000011` (`0x03`) -- `lw` -- загрузить слово из памяти в регистр
- `0000100` (`0x04`) -- `addi` -- прибавить непосредственное значение к регистру
- `0000101` (`0x05`) -- `add` -- сложить значения двух регистров
- `0000110` (`0x06`) -- `adc` -- сложить и положить перенос в регистр
- `0000111` (`0x07`) -- `sub` -- вычесть значение одного регистра из другого
- `0001000` (`0x08`) -- `mul` -- умножить значения двух регистров
- `0001001` (`0x09`) -- `mulh` -- умножить и взять старшую часть результата
- `0001010` (`0x0A`) -- `div` -- разделить значения двух регистров
- `0001011` (`0x0B`) -- `rem` -- получить остаток от деления двух регистров
- `0001100` (`0x0C`) -- `sll` -- сдвинуть значение регистра влево
- `0001101` (`0x0D`) -- `srl` -- сдвинуть значение регистра вправо
- `0001110` (`0x0E`) -- `and` -- выполнить побитовое И над двумя регистрами
- `0001111` (`0x0F`) -- `or` -- выполнить побитовое ИЛИ над двумя регистрами
- `0010000` (`0x10`) -- `xor` -- выполнить побитовое ИСКЛЮЧАЮЩЕЕ ИЛИ над двумя регистрами
- `0010001` (`0x11`) -- `beq` -- перейти, если значения двух регистров равны
- `0010010` (`0x12`) -- `bne` -- перейти, если значения двух регистров не равны
- `0010011` (`0x13`) -- `bgt` -- перейти, если значение одного регистра больше другого
- `0010100` (`0x14`) -- `blt` -- перейти, если значение одного регистра меньше другого
- `0010101` (`0x15`) -- `j` -- перейти со смещением относительно счётчика команд
- `0010110` (`0x16`) -- `jr` -- перейти со смещением относительно регистра
- `0010111` (`0x17`) -- `halt` -- остановить выполнение программы
- `0011000` (`0x18`) -- `eint` -- разрешить прерывания
- `0011001` (`0x19`) -- `dint` -- запретить прерывания
- `0011010` (`0x1A`) -- `rint` -- возврат из прерывания

#### JSON представление

- Машинный код сериализуется в JSON список.
- Один элемент списка -- одна инструкция.

Пример:

```json
[
  {
    "address": 0,
    "opcode": "addi",
    "rd": "t0",
    "rs1": "zero",
    "imm": -10
  },
  {
    "address": 1,
    "opcode": "addi",
    "rd": "sp",
    "rs1": "sp",
    "imm": -1
  },
  {
    "address": 2,
    "opcode": "sw",
    "rd": "None",
    "rs1": "sp",
    "rs2": "t0"
  }
]
```

Где:

- `address` -- адрес инструкции
- `opcode` -- код операции
- `rd`, `rs1`, `rs2`, `imm` -- различные аргументы инструкций

## Транслятор

Интерфейс командной строки: `translator.py <input_file> <target_file>`

Реализовано в модуле: [translator](./src/translator)

Трансляции разделена на несколько этапов:

1. На первом этапе происходит преобразование текста программы в последовательность токенов. Реализовано в
   классе [lexer](
   ./src/translator/lexer.py)
2. Далее набор токенов обрабатывается в соответствии с грамматикой и преобразуется в AST-дерево. Реализовано в
   классе [parser](./src/translator/parser.py). Также на этом этапе происходит:
    - раскрытие пользовательских определений
    - выделение строковых литералов
    - создание таблицы символов
3. На последнем этапе по полученному AST-дереву, таблице символов и списку строковых литералов происходит формирование
   машинного кода. Реализовано в классе [parser](./src/translator/translator.py). Также на этом этапе происходит:
    - Формирования блока данных (сохранение строковых литералов, выделение памяти для переменных)
    - Формирование блока обработки прерываний и его добавление к основной программе

Правила генерации машинного кода:

ДОБАВИТЬ

## Модель процессора

Интерфейс командной строки: `machine.py <machine_code_file> <input_timetable_file>`

Реализовано в модуле: [machine](./src/machine)

### DataPath

Реализован в классе [DataPath](./src/machine/data_path.py)

![data-path.svg](img/data-path.svg)

ДОБАВИТЬ ОПИСАНИЕ

### ControlUnit

Реализован в классе [ControlUnit](./src/machine/control_unit.py)

![control-unit.svg](img/control-unit.svg)

ДОБАВИТЬ ОПИСАНИЕ

## Тестирование

Тестирование выполняется при помощи golden test-ов.

Реализованы в: [golden_bf_test.py](./test/golden_test.py).

Конфигурации:

- [golden/cat.yml](./test/golden/cat.yml)
- [golden/hello.yml](./test/golden/hello.yml)
- [golden/hello_user_name.yml](./test/golden/hello_user_name.yml)

Запустить тесты: `poetry run pytest . -v`

GitHub Actions при совершении `push`-а автоматически

- запускает golden-тесты (задание `test`)
- проверяет форматирование Python и запускает линтеры (`ruff`)
- проверяет форматирование Markdown (`markdownlint`)

Конфигурация для GitHub Actions находится в файлах [python.yaml](.github/workflows/python.yaml)
и [markdown.yaml](.github/workflows/markdown.yaml)

Обновить конфигурацию golden tests:  `poetry run pytest . -v --update-goldens`

### Результаты тестирования

Golden-тесты:

```shell
$ poetry run coverage run -m pytest . -v
=============================================================================== test session starts ================================================================================
platform linux -- Python 3.12.3, pytest-7.4.4, pluggy-1.5.0 -- /home/timur1516/documents/dev/ak/lab4/.venv/bin/python
cachedir: .pytest_cache
rootdir: /home/timur1516/documents/dev/ak/lab4
configfile: pyproject.toml
plugins: golden-0.2.2
collected 3 items                                                                                                                                                                  

test/golden_test.py::test_translator_and_machine[golden/hello_user_name.yml] PASSED                                                                                          [ 33%]
test/golden_test.py::test_translator_and_machine[golden/cat.yml] PASSED                                                                                                      [ 66%]
test/golden_test.py::test_translator_and_machine[golden/hello.yml] PASSED                                                                                                    [100%]

================================================================================ 3 passed in 1.46s =================================================================================
```

Покрытие:

```shell
$ poetry run coverage report -m
Name                                                Stmts   Miss  Cover   Missing
---------------------------------------------------------------------------------
src/__init__.py                                         0      0   100%
src/constants.py                                        6      0   100%
src/isa/__init__.py                                     0      0   100%
src/isa/instructions/__init__.py                        0      0   100%
src/isa/instructions/b_instruction.py                  41      1    98%   75
src/isa/instructions/i_instruction.py                  37      1    97%   69
src/isa/instructions/instruction.py                    18      1    94%   41
src/isa/instructions/j_instruction.py                  26      1    96%   49
src/isa/instructions/jr_instruction.py                 37     18    51%   32-36, 40-42, 47-58, 62, 65
src/isa/instructions/r_instruction.py                  37      1    97%   68
src/isa/instructions/s_instruction.py                  32      1    97%   61
src/isa/instructions/u_instruction.py                  32     13    59%   32-36, 40, 45-53, 57, 60
src/isa/memory_config.py                                6      0   100%
src/isa/opcode_.py                                     34      0   100%
src/isa/opcode_to_instruction_map.py                   11      0   100%
src/isa/register.py                                    15      0   100%
src/isa/util/__init__.py                                0      0   100%
src/isa/util/binary.py                                 22      1    95%   44
src/isa/util/data_translators.py                       78     12    85%   135-149
src/machine/__init__.py                                 0      0   100%
src/machine/control_unit.py                           247     43    83%   127-128, 156, 158, 214-219, 298-328, 338-344
src/machine/data_path.py                               95      8    92%   115, 132, 135, 158, 166, 182, 209-210
src/machine/exceptions/__init__.py                      0      0   100%
src/machine/exceptions/exceptions.py                   11      3    73%   14, 21, 28
src/machine/machine.py                                 42      5    88%   46, 87-90
src/translator/__init__.py                              0      0   100%
src/translator/ast_/__init__.py                         0      0   100%
src/translator/ast_/ast_.py                            73      2    97%   41, 101
src/translator/ast_/ast_node_visitor.py                56     16    71%   35, 51, 56, 59, 62, 65, 68, 71, 74, 77, 80, 83, 86, 89, 92, 95
src/translator/ast_/ast_printer.py                     58      2    97%   40, 82
src/translator/exceptions/__init__.py                   0      0   100%
src/translator/exceptions/exceptions.py                20      9    55%   21-27, 34-35, 42-43
src/translator/lexer.py                                82      1    99%   160
src/translator/parser.py                              187     23    88%   84, 118, 121, 142, 151, 161-165, 172, 180, 195, 200, 226, 232-240, 248, 261
src/translator/token/__init__.py                        0      0   100%
src/translator/token/grammar_start_tokens.py           17      0   100%
src/translator/token/token_.py                         11      1    91%   18
src/translator/token/token_type.py                     47      0   100%
src/translator/translator.py                          126      9    93%   130, 168-171, 240, 246-248
src/translator/traslator_instruction_producers.py      37      6    84%   40-42, 50-52
test/__init__.py                                        0      0   100%
test/golden_test.py                                    33      0   100%
---------------------------------------------------------------------------------
TOTAL                                                1574    178    89%
```

### Алгоритмы согласно варианту

- [hello_world](./test/golden/hello.yml)
- [cat](./test/golden/cat.yml)
- [hello_username](./test/golden/hello_user_name.yml)

### Пример использования модели процессора

ДОБАВИТЬ
